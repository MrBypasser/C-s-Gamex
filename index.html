<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C's Classic Gamex - Tetris</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #282c34;
      color: white;
      text-align: center;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .menu, .game-section {
      display: none;
    }
    .active {
      display: block;
    }
    canvas {
      border: 1px solid white;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: limegreen;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      margin: 10px;
    }
    h1 {
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <h1>C's Classic Gamex - Tetris</h1>

  <div id="menu" class="menu active">
    <h2>Select a Game</h2>
    <button onclick="startTetris()">Play Tetris</button>
    <button onclick="returnToMenu()">Return to Menu</button>
  </div>

  <!-- Tetris Game -->
  <div id="tetris" class="game-section">
    <h2>Tetris Game</h2>
    <canvas id="tetrisCanvas" width="200" height="400"></canvas>
    <p id="tetrisScore">Score: 0</p>
    <button onclick="returnToMenu()">Return to Menu</button>
  </div>

  <script>
    const tetrisCanvas = document.getElementById('tetrisCanvas');
    const tetrisCtx = tetrisCanvas.getContext('2d');
    const scoreElement = document.getElementById('tetrisScore');

    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 20;

    let board, score, activePiece, gameInterval, gameRunning;

    const tetrominoes = [
      [[1, 1, 1], [0, 1, 0]], // T
      [[1, 1], [1, 1]], // O
      [[1, 1, 0], [0, 1, 1]], // S
      [[0, 1, 1], [1, 1, 0]], // Z
      [[1, 0, 0], [1, 1, 1]], // L
      [[0, 0, 1], [1, 1, 1]], // J
      [[1, 1, 1, 1]] // I
    ];

    // Start Game
    function startTetris() {
      gameRunning = true;
      score = 0;
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      updateScore();
      spawnPiece();
      gameInterval = setInterval(gameLoop, 500); // Speed of the game
      document.addEventListener('keydown', handleKeyPress);
    }

    function gameLoop() {
      if (!gameRunning) return;
      movePieceDown();
      drawBoard();
      drawPiece();
    }

    // Handle piece movement
    function movePieceDown() {
      if (canMove(activePiece, 0, 1)) {
        activePiece.y++;
      } else {
        placePiece();
        spawnPiece();
      }
    }

    function canMove(piece, offsetX, offsetY) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x] && (piece.y + y + offsetY >= ROWS || piece.x + x + offsetX < 0 || piece.x + x + offsetX >= COLS || board[piece.y + y + offsetY][piece.x + x + offsetX])) {
            return false;
          }
        }
      }
      return true;
    }

    function placePiece() {
      for (let y = 0; y < activePiece.shape.length; y++) {
        for (let x = 0; x < activePiece.shape[y].length; x++) {
          if (activePiece.shape[y][x]) {
            board[activePiece.y + y][activePiece.x + x] = 1;
          }
        }
      }
      clearRows();
    }

    function clearRows() {
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row].every(cell => cell !== 0)) {
          board.splice(row, 1);
          board.unshift(Array(COLS).fill(0));
          score += 100;
          updateScore();
        }
      }
    }

    // Update the score
    function updateScore() {
      scoreElement.textContent = `Score: ${score}`;
    }

    // Draw the board and piece
    function drawBoard() {
      tetrisCtx.clearRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);

      // Draw the board
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (board[row][col]) {
            tetrisCtx.fillStyle = 'blue';
            tetrisCtx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }

    function drawPiece() {
      tetrisCtx.fillStyle = 'green';
      for (let y = 0; y < activePiece.shape.length; y++) {
        for (let x = 0; x < activePiece.shape[y].length; x++) {
          if (activePiece.shape[y][x]) {
            tetrisCtx.fillRect((activePiece.x + x) * BLOCK_SIZE, (activePiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }

    // Spawn new piece
    function spawnPiece() {
      const randomIndex = Math.floor(Math.random() * tetrominoes.length);
      activePiece = {
        shape: tetrominoes[randomIndex],
        x: Math.floor(COLS / 2) - Math.floor(tetrominoes[randomIndex][0].length / 2),
        y: 0
      };

      if (!canMove(activePiece, 0, 0)) {
        gameOver();
      }
    }

    // Handle keypress events for movement
    function handleKeyPress(e) {
      if (e.key === 'ArrowLeft' && canMove(activePiece, -1, 0)) activePiece.x--;
      if (e.key === 'ArrowRight' && canMove(activePiece, 1, 0)) activePiece.x++;
      if (e.key === 'ArrowDown' && canMove(activePiece, 0, 1)) movePieceDown();
      if (e.key === 'ArrowUp') rotatePiece();
    }

    function rotatePiece() {
      const rotatedPiece = {
        shape: activePiece.shape[0].map((_, index) => activePiece.shape.map(row => row[index])).reverse(),
        x: activePiece.x,
        y: activePiece.y
      };

      if (canMove(rotatedPiece, 0, 0)) {
        activePiece = rotatedPiece;
      }
    }

    // End game
    function gameOver() {
      clearInterval(gameInterval);
      alert('Game Over! Your score: ' + score);
      returnToMenu();
    }

    // Return to menu
    function returnToMenu() {
      clearInterval(gameInterval);
      menu.classList.add('active');
      document.getElementById('tetris').classList.remove('active');
      document.removeEventListener('keydown', handleKeyPress);
    }
  </script>
</body>
</html>

